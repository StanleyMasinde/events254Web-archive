/* tslint:disable */
/* eslint-disable */
/**
 * Events254
 * Events254 internal API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreateEventResponse
 */
export interface CreateEventResponse {
    /**
     * 
     * @type {File}
     * @memberof CreateEventResponse
     */
    'image': File;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'online_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'about': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'endDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'organisable_type': string;
    /**
     * 
     * @type {number}
     * @memberof CreateEventResponse
     */
    'organisable_id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateEventResponse
     */
    'category_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface CreateTicketRequest
 */
export interface CreateTicketRequest {
    /**
     * The price of the current ticket
     * @type {number}
     * @memberof CreateTicketRequest
     */
    'price': number;
    /**
     * The ticket type e.g VIP, Regular
     * @type {string}
     * @memberof CreateTicketRequest
     */
    'type': string;
    /**
     * The maximum number of tickets of this type
     * @type {number}
     * @memberof CreateTicketRequest
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * The unique identifier of the event
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * The url of the image
     * @type {string}
     * @memberof Event
     */
    'image': string;
    /**
     * The title of the event
     * @type {string}
     * @memberof Event
     */
    'about': string;
    /**
     * A HTML description of the event
     * @type {string}
     * @memberof Event
     */
    'description': string;
    /**
     * Start time in ISO UTC
     * @type {string}
     * @memberof Event
     */
    'startDate': string;
    /**
     * End time in ISO UTC
     * @type {string}
     * @memberof Event
     */
    'endDate': string;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'category_id': number;
    /**
     * 
     * @type {EventOrganiser}
     * @memberof Event
     */
    'organiser': EventOrganiser;
    /**
     * 
     * @type {Array<Ticket>}
     * @memberof Event
     */
    'tickets': Array<Ticket>;
    /**
     * True if the event is fee to attent
     * @type {boolean}
     * @memberof Event
     */
    'isFree': boolean;
    /**
     * True if the current event is an all day event
     * @type {boolean}
     * @memberof Event
     */
    'allDay': boolean;
    /**
     * True if the current event is in inProgress
     * @type {boolean}
     * @memberof Event
     */
    'inProgress': boolean;
    /**
     * True if the current event has already passed.
     * @type {boolean}
     * @memberof Event
     */
    'past': boolean;
    /**
     * Shows if the event is published
     * @type {boolean}
     * @memberof Event
     */
    'published'?: boolean;
    /**
     * Shows if the event is a sponsored event
     * @type {boolean}
     * @memberof Event
     */
    'is_sponsored'?: boolean;
    /**
     * True is the current event has an endTime
     * @type {boolean}
     * @memberof Event
     */
    'hasEndTime': boolean;
    /**
     * The people who have registered for the current event
     * @type {Array<User>}
     * @memberof Event
     */
    'attendees': Array<User>;
    /**
     * Show if the current user has persmissions to manage the current event.
     * @type {boolean}
     * @memberof Event
     */
    'can_edit': boolean;
    /**
     * The physical Location of the event. Use address
     * @type {string}
     * @memberof Event
     * @deprecated
     */
    'location': string;
    /**
     * 
     * @type {EventAddress}
     * @memberof Event
     */
    'address'?: EventAddress;
    /**
     * The link to the event if the event is virtual
     * @type {string}
     * @memberof Event
     */
    'online_link': string;
    /**
     * 
     * @type {EventCurrentUserTicket}
     * @memberof Event
     */
    'currentUserTicket'?: EventCurrentUserTicket;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'updated_at': string;
}
/**
 * The address of the event
 * @export
 * @interface EventAddress
 */
export interface EventAddress {
    /**
     * The name of the venue
     * @type {string}
     * @memberof EventAddress
     */
    'name': string;
    /**
     * The formatted address
     * @type {string}
     * @memberof EventAddress
     */
    'formatted_address': string;
}
/**
 * The ticket of the current user if they\'ve purchased one
 * @export
 * @interface EventCurrentUserTicket
 */
export interface EventCurrentUserTicket {
    /**
     * The unique identifier of the pass/ticket
     * @type {number}
     * @memberof EventCurrentUserTicket
     */
    'id': number;
    /**
     * The amount they paid for the tikcet
     * @type {number}
     * @memberof EventCurrentUserTicket
     */
    'price': number;
    /**
     * The number of tickets owned
     * @type {number}
     * @memberof EventCurrentUserTicket
     */
    'rsvp_count': number;
    /**
     * The ticket class e.g VIP
     * @type {string}
     * @memberof EventCurrentUserTicket
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EventOrganiser
 */
export interface EventOrganiser {
    /**
     * Am event can be organized by either an user or a group
     * @type {string}
     * @memberof EventOrganiser
     */
    'type': EventOrganiserTypeEnum;
    /**
     * The id of the organiser
     * @type {number}
     * @memberof EventOrganiser
     */
    'id': number;
    /**
     * The name of the organiser
     * @type {string}
     * @memberof EventOrganiser
     */
    'name': string;
    /**
     * If the event is owned by a group, the admin IDs will be here
     * @type {Array<any>}
     * @memberof EventOrganiser
     */
    'adminIds'?: Array<any>;
}

export const EventOrganiserTypeEnum = {
    User: 'user',
    Group: 'group'
} as const;

export type EventOrganiserTypeEnum = typeof EventOrganiserTypeEnum[keyof typeof EventOrganiserTypeEnum];

/**
 * 
 * @export
 * @interface FeedObject
 */
export interface FeedObject {
    /**
     * The unique identifier
     * @type {string}
     * @memberof FeedObject
     */
    'id': string;
    /**
     * This can be the title
     * @type {string}
     * @memberof FeedObject
     */
    'name': string;
    /**
     * The description
     * @type {string}
     * @memberof FeedObject
     */
    'description': string;
    /**
     * Used to identify the feed item type e.g event or group
     * @type {string}
     * @memberof FeedObject
     */
    'linkPrefix': string;
    /**
     * Start datetime
     * @type {string}
     * @memberof FeedObject
     */
    'startDate'?: string;
    /**
     * End date-time
     * @type {string}
     * @memberof FeedObject
     */
    'endDate'?: string;
    /**
     * The duration if the item is an event
     * @type {string}
     * @memberof FeedObject
     */
    'duration'?: string;
    /**
     * Image url
     * @type {string}
     * @memberof FeedObject
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * This can be the username or email
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * The user\'s current password
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {LoginResponseUser}
     * @memberof LoginResponse
     */
    'user': LoginResponseUser;
}
/**
 * 
 * @export
 * @interface LoginResponseUser
 */
export interface LoginResponseUser {
    /**
     * The unique ID of the user
     * @type {number}
     * @memberof LoginResponseUser
     */
    'id': number;
    /**
     * The name of the user
     * @type {string}
     * @memberof LoginResponseUser
     */
    'name': string;
    /**
     * The email of the user
     * @type {string}
     * @memberof LoginResponseUser
     */
    'email': string;
    /**
     * The autogenerated username of the current user
     * @type {string}
     * @memberof LoginResponseUser
     */
    'username': string;
    /**
     * The bio of the user
     * @type {string}
     * @memberof LoginResponseUser
     */
    'bio': string;
    /**
     * When the user was lasst created
     * @type {string}
     * @memberof LoginResponseUser
     */
    'created_at'?: string;
    /**
     * When the user was last updated
     * @type {string}
     * @memberof LoginResponseUser
     */
    'updated_at'?: string;
    /**
     * The token that will be used to authenticate requests.
     * @type {string}
     * @memberof LoginResponseUser
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Newsfeed
 */
export interface Newsfeed {
    /**
     * 
     * @type {NewsfeedFeedItem}
     * @memberof Newsfeed
     */
    'feedItem': NewsfeedFeedItem;
}
/**
 * 
 * @export
 * @interface NewsfeedFeedItem
 */
export interface NewsfeedFeedItem {
    /**
     * 
     * @type {string}
     * @memberof NewsfeedFeedItem
     */
    'name': string;
    /**
     * 
     * @type {Array<FeedObject>}
     * @memberof NewsfeedFeedItem
     */
    'data': Array<FeedObject>;
}
/**
 * 
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * The full name of the User
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'name': string;
    /**
     * The unique email of the user
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email': string;
    /**
     * The new password of the user
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RequestPassword
 */
export interface RequestPassword {
    /**
     * The current eamil
     * @type {string}
     * @memberof RequestPassword
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SearchResults
 */
export interface SearchResults {
    /**
     * 
     * @type {Array<SearchResultsEventsInner>}
     * @memberof SearchResults
     */
    'events': Array<SearchResultsEventsInner>;
    /**
     * 
     * @type {Array<User>}
     * @memberof SearchResults
     */
    'users': Array<SearchUser>;
}
/**
 * 
 * @export
 * @interface SearchResultsEventsInner
 */
export interface SearchResultsEventsInner {
    /**
     * The unique event id
     * @type {number}
     * @memberof SearchResultsEventsInner
     */
    'id': number;
    /**
     * The title of the event
     * @type {string}
     * @memberof SearchResultsEventsInner
     */
    'about': string;
    /**
     * The event poster url
     * @type {string}
     * @memberof SearchResultsEventsInner
     */
    'image'?: string;
    /**
     * The event location
     * @type {string}
     * @memberof SearchResultsEventsInner
     */
    'location'?: string;
    /**
     * Then event start date
     * @type {string}
     * @memberof SearchResultsEventsInner
     */
    'startDate'?: string;
}
/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {number}
     * @memberof Ticket
     */
    'id': number;
    /**
     * The event that the ticket belogngs to
     * @type {number}
     * @memberof Ticket
     */
    'event_id': number;
    /**
     * The price of the current ticket
     * @type {number}
     * @memberof Ticket
     */
    'price': number;
    /**
     * The type of ticket e.g Regular
     * @type {string}
     * @memberof Ticket
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TicketOrderRequest
 */
export interface TicketOrderRequest {
    /**
     * 
     * @type {number}
     * @memberof TicketOrderRequest
     */
    'ticket_id': number;
    /**
     * 
     * @type {number}
     * @memberof TicketOrderRequest
     */
    'rsvp_count': number;
}
/**
 * 
 * @export
 * @interface TicketOrderResponse
 */
export interface TicketOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof TicketOrderResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof TicketOrderResponse
     */
    'ticketId': number;
}
/**
 * 
 * @export
 * @interface UpdatePasswordRequest
 */
export interface UpdatePasswordRequest {
    /**
     * The current user\'s email
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    'email': string;
    /**
     * The token sent to the email
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    'token': string;
    /**
     * The new password for the user
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The name of the user
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * The email of the user
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * The username of the user
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * The user\'s short introduction
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
}
interface SearchUser extends User {
    'id': number
}
/**
 * The object you get when getting user by Id
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * The name of the user
     * @type {string}
     * @memberof UserProfile
     */
    'name': string;
    /**
     * The username of the user
     * @type {string}
     * @memberof UserProfile
     */
    'username': string;
    /**
     * The bio of the user
     * @type {string}
     * @memberof UserProfile
     */
    'bio'?: string;
    /**
     * When the user was registered
     * @type {string}
     * @memberof UserProfile
     */
    'created_at': string;
    /**
     * 
     * @type {Array<Event>}
     * @memberof UserProfile
     */
    'events': Array<Event>;
}
/**
 * 
 * @export
 * @interface UserTicket
 */
export interface UserTicket {
    /**
     * The image url for the event of this ticket
     * @type {string}
     * @memberof UserTicket
     */
    'image': string;
    /**
     * The name of the event
     * @type {string}
     * @memberof UserTicket
     */
    'eventName': string;
    /**
     * When the event is starting
     * @type {string}
     * @memberof UserTicket
     */
    'eventDate': string;
    /**
     * The end date of the event
     * @type {string}
     * @memberof UserTicket
     */
    'endDate': string;
    /**
     * Where the event will take place can be blank
     * @type {string}
     * @memberof UserTicket
     */
    'eventLocation'?: string;
    /**
     * The unique ID of the current ticket
     * @type {number}
     * @memberof UserTicket
     */
    'ticketId': number;
    /**
     * The unique id of the user that owns the ticket
     * @type {number}
     * @memberof UserTicket
     */
    'userId': number;
    /**
     * The number of tickets/slots purchased
     * @type {number}
     * @memberof UserTicket
     */
    'ticketCount': number;
    /**
     * The class of the ticket e.g early bird,
     * @type {string}
     * @memberof UserTicket
     */
    'ticketType': string;
    /**
     * The amount paid for the ticket
     * @type {number}
     * @memberof UserTicket
     */
    'ticketPrice': number;
    /**
     * the currency that was used to purchase the ticket
     * @type {string}
     * @memberof UserTicket
     */
    'currency': string;
    /**
     * 
     * @type {UserTicketOrganiser}
     * @memberof UserTicket
     */
    'organiser': UserTicketOrganiser;
}
/**
 * The person/group that owns the event
 * @export
 * @interface UserTicketOrganiser
 */
export interface UserTicketOrganiser {
    /**
     * The unique id of the organiser
     * @type {number}
     * @memberof UserTicketOrganiser
     */
    'id': number;
    /**
     * the name of the organiser
     * @type {string}
     * @memberof UserTicketOrganiser
     */
    'name': string;
    /**
     * The URL slug of the organiser if the organiser is a group
     * @type {string}
     * @memberof UserTicketOrganiser
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface ValidationErrors
 */
export interface ValidationErrors {
    /**
     * 
     * @type {Array<any>}
     * @memberof ValidationErrors
     */
    'errors'?: Array<any>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new event as a user
         * @param {string} about The title of the event
         * @param {string} description The description of the event only HTML and plaintext are supported.
         * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
         * @param {string} startDate The date of the event e.g 12/03/2021
         * @param {number} categoryId The category the event belogngs to
         * @param {File} [image] The event poster image.
         * @param {string} [locationName] The name of the location
         * @param {string} [formattedAddress] The formatted address you get from google places api
         * @param {string} [locationCoordinates] The coordinates separated by a comma
         * @param {string} [onlineLink] The online event link if the event is a virtual event
         * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
         * @param {string} [endDate] The date the event is ending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: File, locationName?: string, formattedAddress?: string, locationCoordinates?: string, onlineLink?: string, endTime?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'about' is not null or undefined
            assertParamExists('createEvent', 'about', about)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createEvent', 'description', description)
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('createEvent', 'startTime', startTime)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('createEvent', 'startDate', startDate)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('createEvent', 'categoryId', categoryId)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) {
                localVarFormParams.append('image', image as any);
            }

            if (locationName !== undefined) {
                localVarFormParams.append('location_name', locationName as any);
            }

            if (formattedAddress !== undefined) {
                localVarFormParams.append('formatted_address', formattedAddress as any);
            }

            if (locationCoordinates !== undefined) {
                localVarFormParams.append('location_coordinates', locationCoordinates as any);
            }

            if (onlineLink !== undefined) {
                localVarFormParams.append('online_link', onlineLink as any);
            }

            if (about !== undefined) {
                localVarFormParams.append('about', about as any);
            }

            if (description !== undefined) {
                localVarFormParams.append('description', description as any);
            }

            if (startTime !== undefined) {
                localVarFormParams.append('startTime', startTime as any);
            }

            if (startDate !== undefined) {
                localVarFormParams.append('startDate', startDate as any);
            }

            if (endTime !== undefined) {
                localVarFormParams.append('endTime', endTime as any);
            }

            if (endDate !== undefined) {
                localVarFormParams.append('endDate', endDate as any);
            }

            if (categoryId !== undefined) {
                localVarFormParams.append('category_id', categoryId as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} eventId Event id
         * @param {CreateTicketRequest} createTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (eventId: number, createTicketRequest: CreateTicketRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createTicket', 'eventId', eventId)
            // verify required parameter 'createTicketRequest' is not null or undefined
            assertParamExists('createTicket', 'createTicketRequest', createTicketRequest)
            const localVarPath = `/events/{eventId}/tickets`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createTicketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the events for the currentlty authenticated user
         * @summary Returns all the events by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUsersEvents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/currentUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a ticket
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket: async (eventId: number, ticketId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteTicket', 'eventId', eventId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('deleteTicket', 'ticketId', ticketId)
            const localVarPath = `/events/{eventId}/tickets/{ticketId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a ticket by ID
         * @param {number} ticketId The ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASingleTicket: async (ticketId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('getASingleTicket', 'ticketId', ticketId)
            const localVarPath = `/tickets/{ticketId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the tickets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUsersTickets: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Event by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventById', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTickets: async (eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventTickets', 'eventId', eventId)
            const localVarPath = `/events/{eventId}/tickets`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a ticket by id
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket: async (eventId: number, ticketId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getTicket', 'eventId', eventId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('getTicket', 'ticketId', ticketId)
            const localVarPath = `/events/{eventId}/tickets/{ticketId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user by Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginUser', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the event for the landing page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsfeed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register for event
         * @param {number} eventId Event id
         * @param {TicketOrderRequest} ticketOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderTicket: async (eventId: number, ticketOrderRequest: TicketOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('orderTicket', 'eventId', eventId)
            // verify required parameter 'ticketOrderRequest' is not null or undefined
            assertParamExists('orderTicket', 'ticketOrderRequest', ticketOrderRequest)
            const localVarPath = `/events/{eventId}/register`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(ticketOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ping the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search by calendar
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryCalendar: async (date?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0, 10) :
                    date;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest Create a new user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequest: RegisterUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequest' is not null or undefined
            assertParamExists('registerUser', 'registerUserRequest', registerUserRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a new password
         * @param {RequestPassword} requestPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (requestPassword: RequestPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestPassword' is not null or undefined
            assertParamExists('resetPassword', 'requestPassword', requestPassword)
            const localVarPath = `/auth/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(requestPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for events, people
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('search', 'q', q)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} eventId event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleEventPublishedStatus: async (eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('toggleEventPublishedStatus', 'eventId', eventId)
            const localVarPath = `/events/{eventId}/publish`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update current user
         * @param {User} user Update current user\&#39;s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateCurrentUser', 'user', user)
            const localVarPath = `/users/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a users password
         * @param {UpdatePasswordRequest} updatePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword: async (updatePasswordRequest: UpdatePasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePasswordRequest' is not null or undefined
            assertParamExists('updatePassword', 'updatePasswordRequest', updatePasswordRequest)
            const localVarPath = `/auth/password/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updatePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update ticket information
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket: async (eventId: number, ticketId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateTicket', 'eventId', eventId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('updateTicket', 'ticketId', ticketId)
            const localVarPath = `/events/{eventId}/tickets/{ticketId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new event as a user
         * @param {string} about The title of the event
         * @param {string} description The description of the event only HTML and plaintext are supported.
         * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
         * @param {string} startDate The date of the event e.g 12/03/2021
         * @param {number} categoryId The category the event belogngs to
         * @param {File} [image] The event poster image.
         * @param {string} [locationName] The name of the location
         * @param {string} [formattedAddress] The formatted address you get from google places api
         * @param {string} [locationCoordinates] The coordinates separated by a comma
         * @param {string} [onlineLink] The online event link if the event is a virtual event
         * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
         * @param {string} [endDate] The date the event is ending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: File, locationName?: string, formattedAddress?: string, locationCoordinates?: string, onlineLink?: string, endTime?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(about, description, startTime, startDate, categoryId, image, locationName, formattedAddress, locationCoordinates, onlineLink, endTime, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} eventId Event id
         * @param {CreateTicketRequest} createTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(eventId: number, createTicketRequest: CreateTicketRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(eventId, createTicketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the events for the currentlty authenticated user
         * @summary Returns all the events by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUsersEvents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUsersEvents(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a ticket
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicket(eventId, ticketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a ticket by ID
         * @param {number} ticketId The ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getASingleTicket(ticketId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getASingleTicket(ticketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the tickets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUsersTickets(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserTicket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUsersTickets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Event by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTickets(eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTickets(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the current authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTheCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTheCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a ticket by id
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicket(eventId, ticketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user by Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the event for the landing page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsfeed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Newsfeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsfeed(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * register for event
         * @param {number} eventId Event id
         * @param {TicketOrderRequest} ticketOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderTicket(eventId: number, ticketOrderRequest: TicketOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderTicket(eventId, ticketOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Ping the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search by calendar
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryCalendar(date?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryCalendar(date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest Create a new user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequest: RegisterUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request a new password
         * @param {RequestPassword} requestPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(requestPassword: RequestPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(requestPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for events, people
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} eventId event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleEventPublishedStatus(eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleEventPublishedStatus(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update current user
         * @param {User} user Update current user\&#39;s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a users password
         * @param {UpdatePasswordRequest} updatePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword(updatePasswordRequest: UpdatePasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(updatePasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update ticket information
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicket(eventId, ticketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Create a new event as a user
         * @param {string} about The title of the event
         * @param {string} description The description of the event only HTML and plaintext are supported.
         * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
         * @param {string} startDate The date of the event e.g 12/03/2021
         * @param {number} categoryId The category the event belogngs to
         * @param {File} [image] The event poster image.
         * @param {string} [locationName] The name of the location
         * @param {string} [formattedAddress] The formatted address you get from google places api
         * @param {string} [locationCoordinates] The coordinates separated by a comma
         * @param {string} [onlineLink] The online event link if the event is a virtual event
         * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
         * @param {string} [endDate] The date the event is ending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: File, locationName?: string, formattedAddress?: string, locationCoordinates?: string, onlineLink?: string, endTime?: string, endDate?: string, options?: any): AxiosPromise<CreateEventResponse> {
            return localVarFp.createEvent(about, description, startTime, startDate, categoryId, image, locationName, formattedAddress, locationCoordinates, onlineLink, endTime, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} eventId Event id
         * @param {CreateTicketRequest} createTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(eventId: number, createTicketRequest: CreateTicketRequest, options?: any): AxiosPromise<Array<Ticket>> {
            return localVarFp.createTicket(eventId, createTicketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the events for the currentlty authenticated user
         * @summary Returns all the events by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUsersEvents(options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.currentUsersEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a ticket
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(eventId: number, ticketId: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteTicket(eventId, ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a ticket by ID
         * @param {number} ticketId The ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASingleTicket(ticketId: number, options?: any): AxiosPromise<UserTicket> {
            return localVarFp.getASingleTicket(ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the tickets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUsersTickets(options?: any): AxiosPromise<Array<UserTicket>> {
            return localVarFp.getCurrentUsersTickets(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Event by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(id: number, options?: any): AxiosPromise<Event> {
            return localVarFp.getEventById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTickets(eventId: number, options?: any): AxiosPromise<Array<Ticket>> {
            return localVarFp.getEventTickets(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheCurrentUser(options?: any): AxiosPromise<User> {
            return localVarFp.getTheCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a ticket by id
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket(eventId: number, ticketId: number, options?: any): AxiosPromise<Array<Ticket>> {
            return localVarFp.getTicket(eventId, ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user by Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options?: any): AxiosPromise<UserProfile> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.loginUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the event for the landing page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsfeed(options?: any): AxiosPromise<Newsfeed> {
            return localVarFp.newsfeed(options).then((request) => request(axios, basePath));
        },
        /**
         * register for event
         * @param {number} eventId Event id
         * @param {TicketOrderRequest} ticketOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderTicket(eventId: number, ticketOrderRequest: TicketOrderRequest, options?: any): AxiosPromise<TicketOrderResponse> {
            return localVarFp.orderTicket(eventId, ticketOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Ping the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Search by calendar
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryCalendar(date?: string, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.queryCalendar(date, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest Create a new user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest: RegisterUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a new password
         * @param {RequestPassword} requestPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(requestPassword: RequestPassword, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(requestPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for events, people
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.search(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} eventId event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleEventPublishedStatus(eventId: number, options?: any): AxiosPromise<CreateEventResponse> {
            return localVarFp.toggleEventPublishedStatus(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update current user
         * @param {User} user Update current user\&#39;s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateCurrentUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(id: number, options?: any): AxiosPromise<CreateEventResponse> {
            return localVarFp.updateEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a users password
         * @param {UpdatePasswordRequest} updatePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword(updatePasswordRequest: UpdatePasswordRequest, options?: any): AxiosPromise<string> {
            return localVarFp.updatePassword(updatePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update ticket information
         * @param {number} eventId Event id
         * @param {number} ticketId Event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(eventId: number, ticketId: number, options?: any): AxiosPromise<Array<Ticket>> {
            return localVarFp.updateTicket(eventId, ticketId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Create a new event as a user
     * @param {string} about The title of the event
     * @param {string} description The description of the event only HTML and plaintext are supported.
     * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
     * @param {string} startDate The date of the event e.g 12/03/2021
     * @param {number} categoryId The category the event belogngs to
     * @param {File} [image] The event poster image.
     * @param {string} [locationName] The name of the location
     * @param {string} [formattedAddress] The formatted address you get from google places api
     * @param {string} [locationCoordinates] The coordinates separated by a comma
     * @param {string} [onlineLink] The online event link if the event is a virtual event
     * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
     * @param {string} [endDate] The date the event is ending
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createEvent(about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: File, locationName?: string, formattedAddress?: string, locationCoordinates?: string, onlineLink?: string, endTime?: string, endDate?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createEvent(about, description, startTime, startDate, categoryId, image, locationName, formattedAddress, locationCoordinates, onlineLink, endTime, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} eventId Event id
     * @param {CreateTicketRequest} createTicketRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createTicket(eventId: number, createTicketRequest: CreateTicketRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTicket(eventId, createTicketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the events for the currentlty authenticated user
     * @summary Returns all the events by the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public currentUsersEvents(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).currentUsersEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteEvent(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a ticket
     * @param {number} eventId Event id
     * @param {number} ticketId Event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteTicket(eventId, ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a ticket by ID
     * @param {number} ticketId The ticket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getASingleTicket(ticketId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getASingleTicket(ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the tickets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUsersTickets(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUsersTickets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Event by Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEventById(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEventById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEventTickets(eventId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEventTickets(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTheCurrentUser(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTheCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a ticket by id
     * @param {number} eventId Event id
     * @param {number} ticketId Event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTicket(eventId, ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user by Id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUser(userId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginUser(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the event for the landing page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public newsfeed(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).newsfeed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * register for event
     * @param {number} eventId Event id
     * @param {TicketOrderRequest} ticketOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderTicket(eventId: number, ticketOrderRequest: TicketOrderRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).orderTicket(eventId, ticketOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ping the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ping(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search by calendar
     * @param {string} [date] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public queryCalendar(date?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).queryCalendar(date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterUserRequest} registerUserRequest Create a new user account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerUser(registerUserRequest: RegisterUserRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a new password
     * @param {RequestPassword} requestPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetPassword(requestPassword: RequestPassword, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(requestPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for events, people
     * @param {string} q 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public search(q: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).search(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} eventId event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toggleEventPublishedStatus(eventId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toggleEventPublishedStatus(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update current user
     * @param {User} user Update current user\&#39;s profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateCurrentUser(user: User, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateCurrentUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given event
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateEvent(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a users password
     * @param {UpdatePasswordRequest} updatePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updatePassword(updatePasswordRequest: UpdatePasswordRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updatePassword(updatePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update ticket information
     * @param {number} eventId Event id
     * @param {number} ticketId Event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateTicket(eventId, ticketId, options).then((request) => request(this.axios, this.basePath));
    }
}
