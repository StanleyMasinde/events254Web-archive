/* tslint:disable */
/* eslint-disable */
/**
 * Events254
 * Events254 internal API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


 import { Configuration } from './configuration';
 import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
 // Some imports not used depending on template conditions
 // @ts-ignore
 import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
 // @ts-ignore
 import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';
 
 /**
  * 
  * @export
  * @interface CreateEventResponse
  */
 export interface CreateEventResponse {
     /**
      * 
      * @type {any}
      * @memberof CreateEventResponse
      */
     'image': any;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'location'?: string;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'online_link'?: string;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'about': string;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'description': string;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'startDate': string;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'endDate'?: string;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'organisable_type': string;
     /**
      * 
      * @type {number}
      * @memberof CreateEventResponse
      */
     'organisable_id': number;
     /**
      * 
      * @type {number}
      * @memberof CreateEventResponse
      */
     'category_id': number;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'created_at': string;
     /**
      * 
      * @type {string}
      * @memberof CreateEventResponse
      */
     'updated_at': string;
 }
 /**
  * 
  * @export
  * @interface Event
  */
 export interface Event {
     /**
      * The unique identifier of the event
      * @type {string}
      * @memberof Event
      */
     'id': string;
     /**
      * The url of the image
      * @type {string}
      * @memberof Event
      */
     'image': string;
     /**
      * The title of the event
      * @type {string}
      * @memberof Event
      */
     'about': string;
     /**
      * A HTML description of the event
      * @type {string}
      * @memberof Event
      */
     'description': string;
     /**
      * Start time in ISO UTC
      * @type {string}
      * @memberof Event
      */
     'startDate': string;
     /**
      * End time in ISO UTC
      * @type {string}
      * @memberof Event
      */
     'endDate': string;
     /**
      * 
      * @type {number}
      * @memberof Event
      */
     'category_id': number;
     /**
      * 
      * @type {EventOrganiser}
      * @memberof Event
      */
     'organiser': EventOrganiser;
     /**
      * 
      * @type {Array<Ticket>}
      * @memberof Event
      */
     'tickets': Array<Ticket>;
     /**
      * True if the event is fee to attent
      * @type {boolean}
      * @memberof Event
      */
     'isFree': boolean;
     /**
      * True if the current event is an all day event
      * @type {boolean}
      * @memberof Event
      */
     'allDay': boolean;
     /**
      * True if the current event is in inProgress
      * @type {boolean}
      * @memberof Event
      */
     'inProgress': boolean;
     /**
      * True if the current event has already passed.
      * @type {boolean}
      * @memberof Event
      */
     'past': boolean;
     /**
      * Shows if the event is published
      * @type {boolean}
      * @memberof Event
      */
     'published'?: boolean;
     /**
      * Shows if the event is a sponsored event
      * @type {boolean}
      * @memberof Event
      */
     'is_sponsored'?: boolean;
     /**
      * True is the current event has an endTime
      * @type {boolean}
      * @memberof Event
      */
     'hasEndTime': boolean;
     /**
      * The people who have registered for the current event
      * @type {Array<User>}
      * @memberof Event
      */
     'attendees': Array<User>;
     /**
      * Show if the current user has persmissions to manage the current event.
      * @type {boolean}
      * @memberof Event
      */
     'can_edit': boolean;
     /**
      * The physical Location of the event
      * @type {string}
      * @memberof Event
      */
     'location': string;
     /**
      * The link to the event if the event is virtual
      * @type {string}
      * @memberof Event
      */
     'online_link': string;
     /**
      * 
      * @type {string}
      * @memberof Event
      */
     'created_at': string;
     /**
      * 
      * @type {string}
      * @memberof Event
      */
     'updated_at': string;
 }
 /**
  * 
  * @export
  * @interface EventOrganiser
  */
 export interface EventOrganiser {
     /**
      * Am event can be organized by either an user or a group
      * @type {string}
      * @memberof EventOrganiser
      */
     'type': EventOrganiserTypeEnum;
     /**
      * The id of the organiser
      * @type {number}
      * @memberof EventOrganiser
      */
     'id': number;
     /**
      * The name of the organiser
      * @type {string}
      * @memberof EventOrganiser
      */
     'name': string;
     /**
      * If the event is owned by a group, the admin IDs will be here
      * @type {Array<any>}
      * @memberof EventOrganiser
      */
     'adminIds'?: Array<any>;
 }
 
 export const EventOrganiserTypeEnum = {
     User: 'user',
     Group: 'group'
 } as const;
 
 export type EventOrganiserTypeEnum = typeof EventOrganiserTypeEnum[keyof typeof EventOrganiserTypeEnum];
 
 /**
  * 
  * @export
  * @interface LoginRequest
  */
 export interface LoginRequest {
     /**
      * This can be the username or email
      * @type {string}
      * @memberof LoginRequest
      */
     'email': string;
     /**
      * The user\'s current password
      * @type {string}
      * @memberof LoginRequest
      */
     'password': string;
 }
 /**
  * 
  * @export
  * @interface LoginResponse
  */
 export interface LoginResponse {
     /**
      * The unique ID of the user
      * @type {number}
      * @memberof LoginResponse
      */
     'id': number;
     /**
      * The name of the user
      * @type {string}
      * @memberof LoginResponse
      */
     'name': string;
     /**
      * The email of the user
      * @type {string}
      * @memberof LoginResponse
      */
     'email': string;
     /**
      * The autogenerated username of the current user
      * @type {string}
      * @memberof LoginResponse
      */
     'username': string;
     /**
      * The bio of the user
      * @type {string}
      * @memberof LoginResponse
      */
     'bio'?: string;
     /**
      * When the user was lasst created
      * @type {string}
      * @memberof LoginResponse
      */
     'created_at'?: string;
     /**
      * When the user was last updated
      * @type {string}
      * @memberof LoginResponse
      */
     'updated_at'?: string;
     /**
      * The token that will be used to authenticate requests.
      * @type {string}
      * @memberof LoginResponse
      */
     'token': string;
 }
 /**
  * 
  * @export
  * @interface Newsfeed
  */
 export interface Newsfeed {
     /**
      * 
      * @type {NewsfeedFeedItem}
      * @memberof Newsfeed
      */
     'feedItem': NewsfeedFeedItem;
 }
 /**
  * 
  * @export
  * @interface NewsfeedFeedItem
  */
 export interface NewsfeedFeedItem {
     /**
      * 
      * @type {string}
      * @memberof NewsfeedFeedItem
      */
     'name': string;
     /**
      * 
      * @type {Array<Event>}
      * @memberof NewsfeedFeedItem
      */
     'data': Array<Event>;
 }
 /**
  * 
  * @export
  * @interface RegisterUserRequest
  */
 export interface RegisterUserRequest {
     /**
      * The full name of the User
      * @type {string}
      * @memberof RegisterUserRequest
      */
     'name': string;
     /**
      * The unique email of the user
      * @type {string}
      * @memberof RegisterUserRequest
      */
     'email': string;
     /**
      * The new password of the user
      * @type {string}
      * @memberof RegisterUserRequest
      */
     'password': string;
 }
 /**
  * 
  * @export
  * @interface RequestPassword
  */
 export interface RequestPassword {
     /**
      * The current eamil
      * @type {string}
      * @memberof RequestPassword
      */
     'email': string;
 }
 /**
  * 
  * @export
  * @interface SearchResults
  */
 export interface SearchResults {
     /**
      * 
      * @type {Array<Event>}
      * @memberof SearchResults
      */
     'events': Array<Event>;
     /**
      * 
      * @type {Array<User>}
      * @memberof SearchResults
      */
     'people': Array<User>;
 }
 /**
  * 
  * @export
  * @interface Ticket
  */
 export interface Ticket {
     /**
      * 
      * @type {number}
      * @memberof Ticket
      */
     'id': number;
     /**
      * The event that the ticket belogngs to
      * @type {number}
      * @memberof Ticket
      */
     'event_id': number;
     /**
      * The price of the current ticket
      * @type {number}
      * @memberof Ticket
      */
     'price': number;
     /**
      * The type of ticket e.g Regular
      * @type {string}
      * @memberof Ticket
      */
     'type': string;
 }
 /**
  * 
  * @export
  * @interface TicketOrderRequest
  */
 export interface TicketOrderRequest {
     /**
      * 
      * @type {number}
      * @memberof TicketOrderRequest
      */
     'ticket_id': number;
     /**
      * 
      * @type {number}
      * @memberof TicketOrderRequest
      */
     'event_id': number;
 }
 /**
  * 
  * @export
  * @interface TicketOrderResponse
  */
 export interface TicketOrderResponse {
     /**
      * 
      * @type {string}
      * @memberof TicketOrderResponse
      */
     'message': string;
     /**
      * 
      * @type {number}
      * @memberof TicketOrderResponse
      */
     'ticketId': number;
 }
 /**
  * 
  * @export
  * @interface UpdatePasswordRequest
  */
 export interface UpdatePasswordRequest {
     /**
      * The current user\'s email
      * @type {string}
      * @memberof UpdatePasswordRequest
      */
     'email': string;
     /**
      * The token sent to the email
      * @type {string}
      * @memberof UpdatePasswordRequest
      */
     'token': string;
     /**
      * The new password for the user
      * @type {string}
      * @memberof UpdatePasswordRequest
      */
     'passoword': string;
 }
 /**
  * 
  * @export
  * @interface User
  */
 export interface User {
     /**
      * The name of the user
      * @type {string}
      * @memberof User
      */
     'name': string;
     /**
      * The email of the user
      * @type {string}
      * @memberof User
      */
     'email': string;
     /**
      * The username of the user
      * @type {string}
      * @memberof User
      */
     'username': string;
     /**
      * The user\'s short introduction
      * @type {string}
      * @memberof User
      */
     'bio'?: string;
 }
 /**
  * 
  * @export
  * @interface ValidationErrors
  */
 export interface ValidationErrors {
     /**
      * 
      * @type {Array<any>}
      * @memberof ValidationErrors
      */
     'errors'?: Array<any>;
 }
 
 /**
  * DefaultApi - axios parameter creator
  * @export
  */
 export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Create a new event as a user
          * @param {string} about The title of the event
          * @param {string} description The description of the event only HTML and plaintext are supported.
          * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
          * @param {string} startDate The date of the event e.g 12/03/2021
          * @param {number} categoryId The category the event belogngs to
          * @param {any} [image] The event poster image.
          * @param {string} [location] The event address if the event is an in-person event
          * @param {string} [onlineLink] The online event link if the event is a virtual event
          * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
          * @param {string} [endDate] The date the event is ending
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createEvent: async (about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: any, location?: string, onlineLink?: string, endTime?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'about' is not null or undefined
             assertParamExists('createEvent', 'about', about)
             // verify required parameter 'description' is not null or undefined
             assertParamExists('createEvent', 'description', description)
             // verify required parameter 'startTime' is not null or undefined
             assertParamExists('createEvent', 'startTime', startTime)
             // verify required parameter 'startDate' is not null or undefined
             assertParamExists('createEvent', 'startDate', startDate)
             // verify required parameter 'categoryId' is not null or undefined
             assertParamExists('createEvent', 'categoryId', categoryId)
             const localVarPath = `/events`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
             const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
             if (image !== undefined) { 
                 localVarFormParams.append('image', image as any);
             }
     
             if (location !== undefined) { 
                 localVarFormParams.append('location', location as any);
             }
     
             if (onlineLink !== undefined) { 
                 localVarFormParams.append('online_link', onlineLink as any);
             }
     
             if (about !== undefined) { 
                 localVarFormParams.append('about', about as any);
             }
     
             if (description !== undefined) { 
                 localVarFormParams.append('description', description as any);
             }
     
             if (startTime !== undefined) { 
                 localVarFormParams.append('startTime', startTime as any);
             }
     
             if (startDate !== undefined) { 
                 localVarFormParams.append('startDate', startDate as any);
             }
     
             if (endTime !== undefined) { 
                 localVarFormParams.append('endTime', endTime as any);
             }
     
             if (endDate !== undefined) { 
                 localVarFormParams.append('endDate', endDate as any);
             }
     
             if (categoryId !== undefined) { 
                 localVarFormParams.append('category_id', categoryId as any);
             }
     
     
             localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             localVarRequestOptions.data = localVarFormParams;
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {number} eventId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createTicket: async (eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'eventId' is not null or undefined
             assertParamExists('createTicket', 'eventId', eventId)
             const localVarPath = `/events/{eventId}/tickets`
                 .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Get the events for the currentlty authenticated user
          * @summary Returns all the events by the current user
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         currentUsersEvents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             const localVarPath = `/events/currentUser`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Delete an event
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         deleteEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'id' is not null or undefined
             assertParamExists('deleteEvent', 'id', id)
             const localVarPath = `/events/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Delete a ticket
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         deleteTicket: async (eventId: number, ticketId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'eventId' is not null or undefined
             assertParamExists('deleteTicket', 'eventId', eventId)
             // verify required parameter 'ticketId' is not null or undefined
             assertParamExists('deleteTicket', 'ticketId', ticketId)
             const localVarPath = `/events/{eventId}/tickets/{ticketId}`
                 .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                 .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Get Event by Id
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getEventById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'id' is not null or undefined
             assertParamExists('getEventById', 'id', id)
             const localVarPath = `/events/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {number} eventId 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getEventTickets: async (eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'eventId' is not null or undefined
             assertParamExists('getEventTickets', 'eventId', eventId)
             const localVarPath = `/events/{eventId}/tickets`
                 .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Get the current authenticated user
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getTheCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             const localVarPath = `/auth/user`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Get a ticket by id
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getTicket: async (eventId: number, ticketId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'eventId' is not null or undefined
             assertParamExists('getTicket', 'eventId', eventId)
             // verify required parameter 'ticketId' is not null or undefined
             assertParamExists('getTicket', 'ticketId', ticketId)
             const localVarPath = `/events/{eventId}/tickets/{ticketId}`
                 .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                 .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Get user by Id
          * @param {number} userId 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'userId' is not null or undefined
             assertParamExists('getUser', 'userId', userId)
             const localVarPath = `/users/{userId}`
                 .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         loginUser: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'loginRequest' is not null or undefined
             assertParamExists('loginUser', 'loginRequest', loginRequest)
             const localVarPath = `/auth/login`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Get the event for the landing page
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         newsfeed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             const localVarPath = `/feed`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * register for event
          * @param {number} eventId Event id
          * @param {TicketOrderRequest} ticketOrderRequest 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         orderTicket: async (eventId: number, ticketOrderRequest: TicketOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'eventId' is not null or undefined
             assertParamExists('orderTicket', 'eventId', eventId)
             // verify required parameter 'ticketOrderRequest' is not null or undefined
             assertParamExists('orderTicket', 'ticketOrderRequest', ticketOrderRequest)
             const localVarPath = `/events/{eventId}/register`
                 .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             localVarRequestOptions.data = serializeDataIfNeeded(ticketOrderRequest, localVarRequestOptions, configuration)
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Ping the API
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             const localVarPath = `/ping`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Search by calendar
          * @param {string} [date] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         queryCalendar: async (date?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             const localVarPath = `/search/calendar`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             if (date !== undefined) {
                 localVarQueryParameter['date'] = (date as any instanceof Date) ?
                     (date as any).toISOString().substr(0,10) :
                     date;
             }
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {RegisterUserRequest} registerUserRequest Create a new user account
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         registerUser: async (registerUserRequest: RegisterUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'registerUserRequest' is not null or undefined
             assertParamExists('registerUser', 'registerUserRequest', registerUserRequest)
             const localVarPath = `/auth/register`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Request a new password
          * @param {RequestPassword} requestPassword 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         resetPassword: async (requestPassword: RequestPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'requestPassword' is not null or undefined
             assertParamExists('resetPassword', 'requestPassword', requestPassword)
             const localVarPath = `/auth/password`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             localVarRequestOptions.data = serializeDataIfNeeded(requestPassword, localVarRequestOptions, configuration)
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Search for events, people
          * @param {string} q 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         search: async (q: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'q' is not null or undefined
             assertParamExists('search', 'q', q)
             const localVarPath = `/search`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             if (q !== undefined) {
                 localVarQueryParameter['q'] = q;
             }
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {number} eventId event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         toggleEventPublishedStatus: async (eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'eventId' is not null or undefined
             assertParamExists('toggleEventPublishedStatus', 'eventId', eventId)
             const localVarPath = `/events/{eventId}/publish`
                 .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Update current user
          * @param {User} user Update current user\&#39;s profile
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updateCurrentUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'user' is not null or undefined
             assertParamExists('updateCurrentUser', 'user', user)
             const localVarPath = `/users/update`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Update a given event
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updateEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'id' is not null or undefined
             assertParamExists('updateEvent', 'id', id)
             const localVarPath = `/events/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication bearerAuth required
             // http bearer authentication required
             await setBearerAuthToObject(localVarHeaderParameter, configuration)
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Update a users password
          * @param {UpdatePasswordRequest} updatePasswordRequest 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updatePassoword: async (updatePasswordRequest: UpdatePasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'updatePasswordRequest' is not null or undefined
             assertParamExists('updatePassoword', 'updatePasswordRequest', updatePasswordRequest)
             const localVarPath = `/auth/password/update`;
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             localVarRequestOptions.data = serializeDataIfNeeded(updatePasswordRequest, localVarRequestOptions, configuration)
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * update ticket information
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updateTicket: async (eventId: number, ticketId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
             // verify required parameter 'eventId' is not null or undefined
             assertParamExists('updateTicket', 'eventId', eventId)
             // verify required parameter 'ticketId' is not null or undefined
             assertParamExists('updateTicket', 'ticketId', ticketId)
             const localVarPath = `/events/{eventId}/tickets/{ticketId}`
                 .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                 .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
             // use dummy base URL string because the URL constructor only accepts absolute URLs.
             const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
 
             const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             setSearchParams(localVarUrlObj, localVarQueryParameter);
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: toPathString(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * DefaultApi - functional programming interface
  * @export
  */
 export const DefaultApiFp = function(configuration?: Configuration) {
     const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
     return {
         /**
          * Create a new event as a user
          * @param {string} about The title of the event
          * @param {string} description The description of the event only HTML and plaintext are supported.
          * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
          * @param {string} startDate The date of the event e.g 12/03/2021
          * @param {number} categoryId The category the event belogngs to
          * @param {any} [image] The event poster image.
          * @param {string} [location] The event address if the event is an in-person event
          * @param {string} [onlineLink] The online event link if the event is a virtual event
          * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
          * @param {string} [endDate] The date the event is ending
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createEvent(about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: any, location?: string, onlineLink?: string, endTime?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEventResponse>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(about, description, startTime, startDate, categoryId, image, location, onlineLink, endTime, endDate, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * 
          * @param {number} eventId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createTicket(eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(eventId, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Get the events for the currentlty authenticated user
          * @summary Returns all the events by the current user
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async currentUsersEvents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.currentUsersEvents(options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Delete an event
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async deleteEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Delete a ticket
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async deleteTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicket(eventId, ticketId, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Get Event by Id
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async getEventById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(id, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * 
          * @param {number} eventId 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async getEventTickets(eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTickets(eventId, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Get the current authenticated user
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async getTheCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.getTheCurrentUser(options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Get a ticket by id
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async getTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.getTicket(eventId, ticketId, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Get user by Id
          * @param {number} userId 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async getUser(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * 
          * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async loginUser(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginRequest, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Get the event for the landing page
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async newsfeed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Newsfeed>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.newsfeed(options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * register for event
          * @param {number} eventId Event id
          * @param {TicketOrderRequest} ticketOrderRequest 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async orderTicket(eventId: number, ticketOrderRequest: TicketOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketOrderResponse>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.orderTicket(eventId, ticketOrderRequest, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Ping the API
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Search by calendar
          * @param {string} [date] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async queryCalendar(date?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.queryCalendar(date, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * 
          * @param {RegisterUserRequest} registerUserRequest Create a new user account
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async registerUser(registerUserRequest: RegisterUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Request a new password
          * @param {RequestPassword} requestPassword 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async resetPassword(requestPassword: RequestPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(requestPassword, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Search for events, people
          * @param {string} q 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async search(q: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * 
          * @param {number} eventId event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async toggleEventPublishedStatus(eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEventResponse>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.toggleEventPublishedStatus(eventId, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Update current user
          * @param {User} user Update current user\&#39;s profile
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async updateCurrentUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(user, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Update a given event
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async updateEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEventResponse>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * Update a users password
          * @param {UpdatePasswordRequest} updatePasswordRequest 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async updatePassoword(updatePasswordRequest: UpdatePasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassoword(updatePasswordRequest, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
         /**
          * update ticket information
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async updateTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
             const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicket(eventId, ticketId, options);
             return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
         },
     }
 };
 
 /**
  * DefaultApi - factory interface
  * @export
  */
 export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
     const localVarFp = DefaultApiFp(configuration)
     return {
         /**
          * Create a new event as a user
          * @param {string} about The title of the event
          * @param {string} description The description of the event only HTML and plaintext are supported.
          * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
          * @param {string} startDate The date of the event e.g 12/03/2021
          * @param {number} categoryId The category the event belogngs to
          * @param {any} [image] The event poster image.
          * @param {string} [location] The event address if the event is an in-person event
          * @param {string} [onlineLink] The online event link if the event is a virtual event
          * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
          * @param {string} [endDate] The date the event is ending
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createEvent(about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: any, location?: string, onlineLink?: string, endTime?: string, endDate?: string, options?: any): AxiosPromise<CreateEventResponse> {
             return localVarFp.createEvent(about, description, startTime, startDate, categoryId, image, location, onlineLink, endTime, endDate, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {number} eventId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createTicket(eventId: number, options?: any): AxiosPromise<Array<Ticket>> {
             return localVarFp.createTicket(eventId, options).then((request) => request(axios, basePath));
         },
         /**
          * Get the events for the currentlty authenticated user
          * @summary Returns all the events by the current user
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         currentUsersEvents(options?: any): AxiosPromise<Array<Event>> {
             return localVarFp.currentUsersEvents(options).then((request) => request(axios, basePath));
         },
         /**
          * Delete an event
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         deleteEvent(id: number, options?: any): AxiosPromise<string> {
             return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
         },
         /**
          * Delete a ticket
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         deleteTicket(eventId: number, ticketId: number, options?: any): AxiosPromise<string> {
             return localVarFp.deleteTicket(eventId, ticketId, options).then((request) => request(axios, basePath));
         },
         /**
          * Get Event by Id
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getEventById(id: number, options?: any): AxiosPromise<Event> {
             return localVarFp.getEventById(id, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {number} eventId 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getEventTickets(eventId: number, options?: any): AxiosPromise<Array<Ticket>> {
             return localVarFp.getEventTickets(eventId, options).then((request) => request(axios, basePath));
         },
         /**
          * Get the current authenticated user
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getTheCurrentUser(options?: any): AxiosPromise<User> {
             return localVarFp.getTheCurrentUser(options).then((request) => request(axios, basePath));
         },
         /**
          * Get a ticket by id
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getTicket(eventId: number, ticketId: number, options?: any): AxiosPromise<Array<Ticket>> {
             return localVarFp.getTicket(eventId, ticketId, options).then((request) => request(axios, basePath));
         },
         /**
          * Get user by Id
          * @param {number} userId 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         getUser(userId: number, options?: any): AxiosPromise<User> {
             return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         loginUser(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
             return localVarFp.loginUser(loginRequest, options).then((request) => request(axios, basePath));
         },
         /**
          * Get the event for the landing page
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         newsfeed(options?: any): AxiosPromise<Newsfeed> {
             return localVarFp.newsfeed(options).then((request) => request(axios, basePath));
         },
         /**
          * register for event
          * @param {number} eventId Event id
          * @param {TicketOrderRequest} ticketOrderRequest 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         orderTicket(eventId: number, ticketOrderRequest: TicketOrderRequest, options?: any): AxiosPromise<TicketOrderResponse> {
             return localVarFp.orderTicket(eventId, ticketOrderRequest, options).then((request) => request(axios, basePath));
         },
         /**
          * Ping the API
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         ping(options?: any): AxiosPromise<string> {
             return localVarFp.ping(options).then((request) => request(axios, basePath));
         },
         /**
          * Search by calendar
          * @param {string} [date] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         queryCalendar(date?: string, options?: any): AxiosPromise<Array<Event>> {
             return localVarFp.queryCalendar(date, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {RegisterUserRequest} registerUserRequest Create a new user account
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         registerUser(registerUserRequest: RegisterUserRequest, options?: any): AxiosPromise<User> {
             return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
         },
         /**
          * Request a new password
          * @param {RequestPassword} requestPassword 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         resetPassword(requestPassword: RequestPassword, options?: any): AxiosPromise<void> {
             return localVarFp.resetPassword(requestPassword, options).then((request) => request(axios, basePath));
         },
         /**
          * Search for events, people
          * @param {string} q 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         search(q: string, options?: any): AxiosPromise<SearchResults> {
             return localVarFp.search(q, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {number} eventId event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         toggleEventPublishedStatus(eventId: number, options?: any): AxiosPromise<CreateEventResponse> {
             return localVarFp.toggleEventPublishedStatus(eventId, options).then((request) => request(axios, basePath));
         },
         /**
          * Update current user
          * @param {User} user Update current user\&#39;s profile
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updateCurrentUser(user: User, options?: any): AxiosPromise<User> {
             return localVarFp.updateCurrentUser(user, options).then((request) => request(axios, basePath));
         },
         /**
          * Update a given event
          * @param {number} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updateEvent(id: number, options?: any): AxiosPromise<CreateEventResponse> {
             return localVarFp.updateEvent(id, options).then((request) => request(axios, basePath));
         },
         /**
          * Update a users password
          * @param {UpdatePasswordRequest} updatePasswordRequest 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updatePassoword(updatePasswordRequest: UpdatePasswordRequest, options?: any): AxiosPromise<string> {
             return localVarFp.updatePassoword(updatePasswordRequest, options).then((request) => request(axios, basePath));
         },
         /**
          * update ticket information
          * @param {number} eventId Event id
          * @param {number} ticketId Event id
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updateTicket(eventId: number, ticketId: number, options?: any): AxiosPromise<Array<Ticket>> {
             return localVarFp.updateTicket(eventId, ticketId, options).then((request) => request(axios, basePath));
         },
     };
 };
 
 /**
  * DefaultApi - object-oriented interface
  * @export
  * @class DefaultApi
  * @extends {BaseAPI}
  */
 export class DefaultApi extends BaseAPI {
     /**
      * Create a new event as a user
      * @param {string} about The title of the event
      * @param {string} description The description of the event only HTML and plaintext are supported.
      * @param {string} startTime The time the event is starting in 2hrs e.g 09:00, 23:00
      * @param {string} startDate The date of the event e.g 12/03/2021
      * @param {number} categoryId The category the event belogngs to
      * @param {any} [image] The event poster image.
      * @param {string} [location] The event address if the event is an in-person event
      * @param {string} [onlineLink] The online event link if the event is a virtual event
      * @param {string} [endTime] The time the event is ending ins 24hrs format e.g 23:00
      * @param {string} [endDate] The date the event is ending
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public createEvent(about: string, description: string, startTime: string, startDate: string, categoryId: number, image?: any, location?: string, onlineLink?: string, endTime?: string, endDate?: string, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).createEvent(about, description, startTime, startDate, categoryId, image, location, onlineLink, endTime, endDate, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {number} eventId Event id
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public createTicket(eventId: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).createTicket(eventId, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Get the events for the currentlty authenticated user
      * @summary Returns all the events by the current user
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public currentUsersEvents(options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).currentUsersEvents(options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Delete an event
      * @param {number} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public deleteEvent(id: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Delete a ticket
      * @param {number} eventId Event id
      * @param {number} ticketId Event id
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public deleteTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).deleteTicket(eventId, ticketId, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Get Event by Id
      * @param {number} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public getEventById(id: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).getEventById(id, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {number} eventId 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public getEventTickets(eventId: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).getEventTickets(eventId, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Get the current authenticated user
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public getTheCurrentUser(options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).getTheCurrentUser(options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Get a ticket by id
      * @param {number} eventId Event id
      * @param {number} ticketId Event id
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public getTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).getTicket(eventId, ticketId, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Get user by Id
      * @param {number} userId 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public getUser(userId: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {LoginRequest} loginRequest Attempt to authenticate a user and get a token
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public loginUser(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).loginUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Get the event for the landing page
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public newsfeed(options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).newsfeed(options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * register for event
      * @param {number} eventId Event id
      * @param {TicketOrderRequest} ticketOrderRequest 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public orderTicket(eventId: number, ticketOrderRequest: TicketOrderRequest, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).orderTicket(eventId, ticketOrderRequest, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Ping the API
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public ping(options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Search by calendar
      * @param {string} [date] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public queryCalendar(date?: string, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).queryCalendar(date, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {RegisterUserRequest} registerUserRequest Create a new user account
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public registerUser(registerUserRequest: RegisterUserRequest, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Request a new password
      * @param {RequestPassword} requestPassword 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public resetPassword(requestPassword: RequestPassword, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).resetPassword(requestPassword, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Search for events, people
      * @param {string} q 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public search(q: string, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).search(q, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {number} eventId event id
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public toggleEventPublishedStatus(eventId: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).toggleEventPublishedStatus(eventId, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Update current user
      * @param {User} user Update current user\&#39;s profile
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public updateCurrentUser(user: User, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).updateCurrentUser(user, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Update a given event
      * @param {number} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public updateEvent(id: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).updateEvent(id, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * Update a users password
      * @param {UpdatePasswordRequest} updatePasswordRequest 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public updatePassoword(updatePasswordRequest: UpdatePasswordRequest, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).updatePassoword(updatePasswordRequest, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * update ticket information
      * @param {number} eventId Event id
      * @param {number} ticketId Event id
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof DefaultApi
      */
     public updateTicket(eventId: number, ticketId: number, options?: AxiosRequestConfig) {
         return DefaultApiFp(this.configuration).updateTicket(eventId, ticketId, options).then((request) => request(this.axios, this.basePath));
     }
 }
 
 
 